# Sunday, January 6, 2019

## Everyday Tasks:
    ### 锻炼:
        ☐ 跑步三圈     @5m
        ☐ 俯卧撑40下   @10m
        ☐ 拉伸腿20下   @5m
        ☐ 跳跃100下    @5m
        ☐ 深蹲50下     @5m
    ### 扇贝单词:
        ☐ 每日打卡     @5m

## Tasks:

## Notes:

### 2019-01-06 15:17:24
> &emsp;&emsp;昨天是周六，本来想着下周一是马克思考试要好好复习的，但是在深圳自如家里没有学习状态，所以就兜兜转转完了一天_(:зゝ∠)_
> &emsp;&emsp;也因为这样，昨天没有做运动，没有打卡，也没有做笔记，甚是惭愧。
> &emsp;&emsp;今天早上也是如此，因为昨晚问了学委之后得知，马克思原来是开卷考试的，所以又玩了一个早上。
> &emsp;&emsp;接近饭点的时候，原本我是计划11点会广州的，但是后面又不想急着回去（惦记着这几天的OpenMaya的效果）
> &emsp;&emsp;所以我就回到公司继续研究 OpenMaya 了。

> &emsp;&emsp;目前已经有了不少进度，现在已经锁定到了 C++ 的 BasicBlendShape 案例中。
> &emsp;&emsp;我原本以为要想 jlCollisonDeformer 一样从零开始驱动驱动点信息。
> &emsp;&emsp;所以我的想法和 jlCollisonDeformer 的内核实现一样。
> &emsp;&emsp;先封装一个函数，在外部获取相关的对应关系信息，然后传入到节点的plug中
> &emsp;&emsp;随后在节点的plug中获取相关的数据。
> &emsp;&emsp;但是这个操作最大的问题就是如何获取顶点的信息。
> &emsp;&emsp;可以在 jlCollisionDeformer 以及一堆相关的 C++ Example 中可以看到数据是如何获取调用的
> 
```Python
# 创建 plug
jlCollisionDeformer.collider = gAttr.create( "collider", "coll")
gAttr.addDataAccept( OpenMaya.MFnData.kMesh )

# 获取plug
colliderHandle = dataBlock.inputValue( self.collider )
colliderObject = colliderHandle.asMesh()

```
> &emsp;&emsp;然而让我纠结的是如何获取 component 
> &emsp;&emsp;尽管我也可以传入 intArray ，但是既然有compponent的方案，我就不想放着不用。
> &emsp;&emsp;于是为了找寻这个东西，我在API文档中找了好久才发现，我要的转换原来就在 BasicBlendShape 里面。
> &emsp;&emsp;所以归根结底还是得重新看懂这个脚本的运作原理。
> &emsp;&emsp;之前其实也已经注意到了这个脚本，但是我看到它是继承 MPxBlendshape，而且实现的效果和Blendshape一样，所以我一直不太重视它。
> &emsp;&emsp;后来我重新注释掉一下代码去编译，我才发现，原来这个代码就是实现Blendshape效果的，我把核心代码禁用了之后，Blendshape效果就没了。
> &emsp;&emsp;所以后面重点研究这个脚本的原理

### 
